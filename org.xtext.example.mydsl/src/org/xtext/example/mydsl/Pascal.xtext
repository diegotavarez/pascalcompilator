grammar org.xtext.example.mydsl.Pascal with org.eclipse.xtext.common.Terminals

generate pascal "http://www.xtext.org/example/mydsl/Pascal"

Model:
	programs+=program*;

//PROGRAMS AND BLOCKS
program:
	program_heading block PONTO;
program_heading:
	'program' IDENTIFIER (PARENTESQ  identifier_list PARENTDIR)? PONTOV ;
block:
	declaration_part statement_part;
declaration_part:
	(label_declaration_part)? (constant_definition_part)? (type_definition_part)? (variable_declaration_part)? procedure_and_function_declaration_part;
label_declaration_part:
	'label' label (VIRGULA label)* PONTOV;
constant_definition_part:
	'const' constant_definition PONTOV (constant_definition PONTOV)*;
constant_definition:
	IDENTIFIER IG constant;
type_definition_part:
	'type' type_definition PONTOV (type_definition PONTOV)*; 
type_definition:
	IDENTIFIER IG type;
variable_declaration_part:
	'var' variable_declaration PONTOV (variable_declaration PONTOV)*;
variable_declaration:
	identifier_list DOISPONTOS type; 
procedure_and_function_declaration_part:
	(('procedure_declaration' | 'function_declaration') PONTOV)*;
statement_part:
	'begin' StatementSequence 'end'; 

//STATEMENTS
StatementSequence:
    statement+=Statement (PONTOV statement+=Statement)*
;
Statement:
	(label DOISPONTOS )? statement=(SimpleStatement | StructuredStatement);
SimpleStatement:
	(AssignmentStatement | ProcedureStatement | GotoStatement)
;
AssignmentStatement:
    (variable='variable' | identifier=IDENTIFIER) ATRIBUICAO expression='expression'
;
ProcedureStatement:
    name=IDENTIFIER actualParameterList=('ActualParameterList')?    
;
GotoStatement:
    'goto' label    
;
StructuredStatement:
    CompoundStatement |
    RepetitiveStatement |
    ConditionalStatement | 
    WithStatement
;
CompoundStatement:
    'begin' statementSequence=StatementSequence 'end'
;
RepetitiveStatement:
    Whilestatement |
    RepeatStatement |
    ForStatement    
;
Whilestatement:
    'while' expression='Expression' 'do' statement=Statement
;

RepeatStatement:
    'repeat' statementSequence=StatementSequence 'until' expression='Expression'    
;
ForStatement:
    'for'
;
ConditionalStatement:
    'if'
;

WithStatement: 
    'with'
;



case_label_list:
	constant (VIRGULA constant)*;

//EXPRESSIONS
entire_variable:
	variable_identifier | field_identifier; 

//TYPES
type:
	simple_type | structured_type | pointer_type | type_identifier | 'TESTE';
simple_type:
	subrange_type | enumerated_type;
enumerated_type:
	PARENTESQ identifier_list PARENTDIR; 
subrange_type:
	lower_bound PONTOPONTO upper_bound;
lower_bound:
	constant;
upper_bound:
	constant;
structured_type:
	('packed')? unpacked_structured_type;
unpacked_structured_type:
	array_type | record_type | set_type | file_type;
array_type:
	'array';
index_type:
	simple_type;
element_type:
	type;  
record_type:
	'record' field_list 'end';
set_type:
	'set' 'of' base_type;
base_type:
	type;
file_type:
	'file' 'of' file_component_type;
file_component_type:
	type;
pointer_type:
CHAPEU type_identifier;
	
//RECORD FIELDS
field_list:
	((fixed_part (PONTOV variant_part)? | variant_part) (PONTOV)?)?;
fixed_part:
	record_section (PONTOV record_section)*;
record_section:
	identifier_list DOISPONTOS type;
variant_part:
	'case' tag_field type_identifier 'of' variant (PONTOV variant)*;
tag_field:
	(IDENTIFIER DOISPONTOS)?;
variant:
	case_label_list DOISPONTOS PARENTESQ field_list PARENTDIR;  

//VARIABLE AND IDENTIFIER CATEGORIES
field_identifier:
	IDENTIFIER;
constant_identifier:
	IDENTIFIER;
variable_identifier:
	IDENTIFIER;
type_identifier:
	IDENTIFIER;
procedure_identifier:
	IDENTIFIER;
function_identifier:
	IDENTIFIER;
bound_identifier:
	IDENTIFIER;

//LOW LEVEL DEFINITIONS
identifier_list:
	IDENTIFIER (VIRGULA IDENTIFIER)*;
number:
	integer_number | real_number;
integer_number:
	digit_sequence;
real_number:
	digit_sequence PONTO (UNSIGNED_DIGIT_SEQUENCE)? (scale_factor) | digit_sequence scale_factor;
scale_factor:
	("E" | "e")digit_sequence;
terminal UNSIGNED_DIGIT_SEQUENCE:
	('0'..'9') ('0'..'9')*;
digit_sequence:
	(sign)? UNSIGNED_DIGIT_SEQUENCE;
sign:
	'+' | '-';
label:
	integer_number;
constant:
	(sign)? (constant_identifier | number) | STRING;
	
//TERMINAIS
terminal fragment DIFERENTE : "<>";
terminal fragment MENOR : "<";
terminal fragment MENORIGUAL : "<=";
terminal fragment MAIOR : ">";
terminal fragment MAIORIGUAL : ">=";

terminal fragment MULTIP : "*";
terminal fragment DIVISAO : "/";
terminal PONTOV : ";";
terminal VIRGULA : ",";
terminal PONTO : ".";
terminal DOISPONTOS : ":";
terminal ATRIBUICAO : ":=";
terminal PARENTESQ : "(";
terminal PARENTDIR : ")";
terminal COLCHETEESQ : "[";
terminal COLCHETEDIR : "]";
terminal PONTOPONTO : "..";
terminal CHAPEU : "^";
terminal fragment ASPASSIMPLES : "'";
terminal fragment IGUAL : "==";
terminal IG: "=";                                   //OBS
terminal fragment LETTER : ('a'..'z' |  'A'..'Z');
terminal fragment DIGIT : ('0'..'9');
terminal fragment EXPOENTE: 'E' | 'e';

terminal IDENTIFIER:
    (('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|'_'|('0'..'9'))*;

terminal WS: 
    (' '|'\t'|'\r'|'\n')+
;