grammar org.xtext.example.mydsl.Pascal with org.eclipse.xtext.common.Terminals

generate pascal "http://www.xtext.org/example/mydsl/Pascal"

Model:
	programs+=program*;

//PROGRAMS AND BLOCKS
program:
    program = program_heading block=block DOT;
program_heading:
	'program' IDENTIFIER (LEFT_PARENTHESIS  identifier_list RIGHT_PARENTHESIS) SEMICOLON ;
block:
	declarationPart=DeclarationPart statementPart=StatementPart;
DeclarationPart:
	labelDeclarationPart=(label_declaration_part)?
    constantDefinitionPart=(constant_definition_part)?
    typeDefinitionPart=(type_definition_part)?
    variableDeclarationPart=(variable_declaration_part)?
    procedureAndFunctionDeclarationPart=procedure_and_function_declaration_part;
label_declaration_part:
	'label' label+=label (COMMA label+=label)* SEMICOLON;
constant_definition_part:
	'const' constantDefinition+=constant_definition SEMICOLON (constantDefinition+=constant_definition SEMICOLON)*;
constant_definition:
	IDENTIFIER IG constant;
type_definition_part:
    'type' typeDefinition+=type_definition SEMICOLON (typeDefinition+=type_definition SEMICOLON)*;
type_definition:
	IDENTIFIER IG type;
variable_declaration_part:
    'var' variableDeclaration+=variable_declaration SEMICOLON (variableDeclaration+=variable_declaration SEMICOLON)*;
variable_declaration:
    identifierList=identifier_list COLON type=type;
procedure_and_function_declaration_part:
	{procedure_and_function_declaration_part}
    ( (procedureDeclaration+=ProcedureDeclaration | functionDeclaration+=FunctionDeclaration) SEMICOLON )*;
ProcedureDeclaration:
    'procedure' name=IDENTIFIER (formalParameterList=FormalParameterList)? SEMICOLON block=block;
FunctionDeclaration:
    'function' name=IDENTIFIER (formalParameterList=FormalParameterList)? COLON type=type SEMICOLON block=block ;
StatementPart:
	'begin' StatementSequence 'end'; 

//PROCEDURE AND FUNCTION DEFINITIONS
procedure_heading:
   'procedure' name=IDENTIFIER FormalParameterList=(FormalParameterList)?;
function_heading:
    'function' id1=IDENTIFIER FormalParameterList=(FormalParameterList)? SEMICOLON id2=IDENTIFIER;
procedure_identification:
	'procedure' procedure_identifier;
FormalParameterList:
    LEFT_PARENTHESIS FormalParameterSection+=FormalParameterSection (SEMICOLON FormalParameterSection+=FormalParameterSection)* RIGHT_PARENTHESIS;
FormalParameterSection:
    valueParameterSection=ValueParameterSection |
    variableParamenterSection=VariableParamenterSection |
    procedureHeading=procedure_heading |
    functionHeading=function_heading;
ValueParameterSection:
    identifierList=identifier_list COLON parameterType=ParameterType;
VariableParamenterSection:
    'var' identifierList=identifier_list COLON parameterType=ParameterType;
ParameterType:
    id=IDENTIFIER |
    conformantArraySchema=ConformantArraySchema;
ConformantArraySchema:
    PackedConformantArraySchema |
    UnpackedConformantArraySchema ;
PackedConformantArraySchema:
    'packed array' LEFT_BRACKETS boundSpecification=BoundSpecification RIGHT_BRACKETS 'of' id=IDENTIFIER;
UnpackedConformantArraySchema:
    'array' LEFT_BRACKETS boundSpecification+=BoundSpecification (SEMICOLON boundSpecification+=BoundSpecification)* 
    RIGHT_BRACKETS 'of' (id=IDENTIFIER | conformantArraySchema=ConformantArraySchema);
BoundSpecification:
    id1=IDENTIFIER DIAERESIS id2=IDENTIFIER COLON id3=IDENTIFIER;

//STATEMENTS
StatementSequence:
    statement+=Statement (SEMICOLON statement+=Statement)*;
Statement:
	(label COLON )? statement=(SimpleStatement | StructuredStatement);
SimpleStatement:
	(AssignmentStatement | ProcedureStatement | GotoStatement);
AssignmentStatement:
    (variable='variable' | identifier=IDENTIFIER) ASSIGNMENT_SIGN expression=Expression;
ProcedureStatement:
    name=IDENTIFIER actualParameterList=('ActualParameterList')?;
GotoStatement:
    'goto' label;
StructuredStatement:
    CompoundStatement |
    RepetitiveStatement |
    ConditionalStatement | 
    WithStatement;
CompoundStatement:
    'begin' statementSequence=StatementSequence 'end';
RepetitiveStatement:
    Whilestatement |
    RepeatStatement |
    ForStatement    ;
Whilestatement:
    'while' expression=Expression 'do' statement=Statement;
RepeatStatement:
    'repeat' statementSequence=StatementSequence 'until' expression=Expression    ;
ForStatement:
	'for' name=IDENTIFIER ASSIGNMENT_SIGN expression1=Expression ('to' | 'downto' ) expression2=Expression 'do' statement=Statement;
ConditionalStatement:
    ifStatement=IfStatement | caseStatement=CaseStatement;
IfStatement:
    'if' expression=Expression 'then' ifStatement=Statement (=>'else' elseStatement=Statement)?;
CaseStatement:
    'case' expression=Expression 'of' caseLimb+=CaseLimb (SEMICOLON caseLimb+=CaseLimb)* (SEMICOLON)? 'end';
CaseLimb:
    caseLabelList=case_label_list COLON statement=Statement;
case_label_list:
    constant+=constant (COMMA constant+=constant)*;
WithStatement: 
    'with' variable+=Variable (COMMA variable+=Variable)* 'do' statement=Statement;

//EXPRESSIONS
Expression:
    simpleExpression+=SimpleExpression (relational_operator+=RELATIONALOPERATOR simpleExpression+=SimpleExpression)?;
SimpleExpression:
    ('+' | '-')? term+=Term (ADDITIONOPERATOR term+=Term )*
;
Term:
    factor+=Factor (MULTIPLICATIONOPERATOR factor+=Factor)*;
Factor:
	(=>functionDesignator=FunctionDesignator)
    variable=Variable | number=number | string=STRING1 | set=Set | nil='nil' | id=IDENTIFIER | 
    LEFT_PARENTHESIS expression=Expression RIGHT_PARENTHESIS | 'not' factor=Factor ;
Variable:
    name=IDENTIFIER variable1=(Variable1)?;
Variable1:
    (LEFT_BRACKETS expressionList=ExpressionList RIGHT_BRACKETS) variable1=Variable1 |
    (DOT name=IDENTIFIER) variable1=Variable1 |
    CARET variable1=Variable1;
Set:
    LEFT_BRACKETS elementList=ElementList RIGHT_BRACKETS;
ElementList:
	{ElementList}
    (expression+=Expression (COMMA expression+=Expression)* )?;
FunctionDesignator:
    name=IDENTIFIER 'actualParameterList'?;
entire_variable:
	variable_identifier | field_identifier; 

//TYPES
type:
    simpleType=simple_type |
    structuredType=structured_type |
    pointerType=pointer_type |
    name=IDENTIFIER;
simple_type:
	=>(primitiveType=('boolean'|'char'|'integer'|'real'))
    subrangeType=subrange_type | enumeratedType=enumerated_type;
enumerated_type:
    LEFT_PARENTHESIS identifierList=identifier_list RIGHT_PARENTHESIS;
subrange_type:
    constant=constant DIAERESIS constant2=constant;
structured_type:
    ('packed')? unpackedStructuredType=unpacked_structured_type;
unpacked_structured_type:
    arrayType=array_type |
    recordType=record_type |
    setType=set_type |
    fileType=file_type;
array_type:
    'array' LEFT_BRACKETS simpleType+=simple_type (COMMA simpleType+=simple_type)* RIGHT_BRACKETS 'of' type=type;
record_type:
	'record' fieldlist=field_list 'end';
set_type:
	'set' 'of' type=type;
file_type:
	'file' 'of' type=type;
pointer_type:
	CARET name=IDENTIFIER;
	
//RECORD FIELDS
field_list:
	{field_list}
    ( (fixedPart=fixed_part (SEMICOLON variantPart=variant_part)? | variantPart=variant_part ) (SEMICOLON)? )? ;
fixed_part:
    recordSection+=record_section (SEMICOLON recordSection+=record_section)*;
record_section:
    identifierList=identifier_list COLON type=type;
variant_part:
    'case' tagfield=tag_field id=IDENTIFIER 'of' variant+=variant (SEMICOLON variant+=variant)*;
tag_field:
	{tag_field}
    (id=IDENTIFIER COLON)?;
variant:
    caseLabelList=case_label_list COLON LEFT_PARENTHESIS fieldList=field_list RIGHT_PARENTHESIS;

//VARIABLE AND IDENTIFIER CATEGORIES
field_identifier:
	IDENTIFIER;
constant_identifier:
	IDENTIFIER;
variable_identifier:
	IDENTIFIER;
type_identifier:
	IDENTIFIER;
procedure_identifier:
	IDENTIFIER;
function_identifier:
	IDENTIFIER;
bound_identifier:
	IDENTIFIER;

//LOW LEVEL DEFINITIONS
ExpressionList:
    expression+=Expression (COMMA expression+=Expression)*;
identifier_list:
    ids+=IDENTIFIER (COMMA ids+=IDENTIFIER)*;
number:
    integer=INTEGER_NUMBER |
    real=REAL_NUMBER;
label:
    int=INTEGER_NUMBER;
scale_factor:
	("E" | "e")digit_sequence;
terminal UNSIGNED_DIGIT_SEQUENCE:
	('0'..'9') ('0'..'9')*;
digit_sequence:
	(sign)? UNSIGNED_DIGIT_SEQUENCE;
sign:
	'+' | '-';
constant:
    ('+' | '-')? (name=IDENTIFIER | number=number) | string=STRING1;    
terminal RELATIONALOPERATOR:
    EQUALS_SIGN | DIFFERENT_SIGN | LESS_THAN_SIGN | LESS_OR_EQUALS_SIGN | GREATER_THAN_SIGN | GREATER_OR_EQUALS_SIGN | 'in'
;

terminal ADDITIONOPERATOR:
    '+' | '-' | 'or';
terminal MULTIPLICATIONOPERATOR:
    MULTIP_SIGN | DIV_SIGN | 'div' | 'mod' | 'and';
terminal INTEGER_NUMBER:
    ('+' | '-')? DIGIT+;
terminal REAL_NUMBER:
    ('+' | '-')? DIGIT+ ((DOT DIGIT* (EXPOENTE ('+' | '-')? DIGIT+)?) |(EXPOENTE ('+' | '-')? DIGIT+) );
terminal STRING1:
    ASPASSIMPLES STRINGCHARACTER (STRINGCHARACTER)* ASPASSIMPLES;
terminal STRINGCHARACTER:
"''" | (LETTER | DIGIT);

//TERMINAIS
terminal fragment DIFFERENT_SIGN : "<>";
terminal fragment LESS_THAN_SIGN : "<";
terminal fragment LESS_OR_EQUALS_SIGN : "<=";
terminal fragment GREATER_THAN_SIGN : ">";
terminal fragment GREATER_OR_EQUALS_SIGN : ">=";

terminal fragment MULTIP_SIGN : "*";
terminal fragment DIV_SIGN : "/";
terminal SEMICOLON : ";";
terminal COMMA : ",";
terminal DOT : ".";
terminal COLON : ":";
terminal ASSIGNMENT_SIGN : ":=";
terminal LEFT_PARENTHESIS : "(";
terminal RIGHT_PARENTHESIS : ")";
terminal LEFT_BRACKETS : "[";
terminal RIGHT_BRACKETS : "]";
terminal DIAERESIS : "..";
terminal CARET : "^";
terminal fragment ASPASSIMPLES : "'";
terminal fragment EQUALS_SIGN : "==";
terminal IG: "=";                                   //OBS
terminal fragment LETTER : ('a'..'z' |  'A'..'Z');
terminal fragment DIGIT : ('0'..'9');
terminal fragment EXPOENTE: 'E' | 'e';

terminal IDENTIFIER:
    (('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|'_'|('0'..'9'))*;

terminal WS: 
    (' '|'\t'|'\r'|'\n')+
;