grammar org.xtext.example.mydsl.Pascal with org.eclipse.xtext.common.Terminals

generate pascal "http://www.xtext.org/example/mydsl/Pascal"

Model:
	programs+=program*;

//PROGRAMS AND BLOCKS
program:
    program = program_heading block=block PONTO;
program_heading:
	'program' IDENTIFIER (PARENTESQ  identifier_list PARENTDIR) PONTOV ;
block:
	declarationPart=DeclarationPart statementPart=StatementPart;
DeclarationPart:
	labelDeclarationPart=(label_declaration_part)?
    constantDefinitionPart=(constant_definition_part)?
    typeDefinitionPart=(type_definition_part)?
    variableDeclarationPart=(variable_declaration_part)?
    procedureAndFunctionDeclarationPart=procedure_and_function_declaration_part;
label_declaration_part:
	'label' label+=label (VIRGULA label+=label)* PONTOV;
constant_definition_part:
	'const' constantDefinition+=constant_definition PONTOV (constantDefinition+=constant_definition PONTOV)*;
constant_definition:
	IDENTIFIER IG constant;
type_definition_part:
    'type' typeDefinition+=type_definition PONTOV (typeDefinition+=type_definition PONTOV)*;
type_definition:
	IDENTIFIER IG type;
variable_declaration_part:
    'var' variableDeclaration+=variable_declaration PONTOV (variableDeclaration+=variable_declaration PONTOV)*;
variable_declaration:
    identifierList=identifier_list DOISPONTOS type=type;
procedure_and_function_declaration_part:
	{procedure_and_function_declaration_part}
    ( (procedureDeclaration+=ProcedureDeclaration | functionDeclaration+=FunctionDeclaration) PONTOV )*;
ProcedureDeclaration:
    'procedure' name=IDENTIFIER (formalParameterList=FormalParameterList)? PONTOV block=block;
FunctionDeclaration:
    'function' name=IDENTIFIER (formalParameterList=FormalParameterList)? DOISPONTOS type=type PONTOV block=block ;
StatementPart:
	'begin' StatementSequence 'end'; 

//PROCEDURE AND FUNCTION DEFINITIONS
procedure_heading:
   'procedure' name=IDENTIFIER FormalParameterList=(FormalParameterList)?;
function_heading:
    'function' id1=IDENTIFIER FormalParameterList=(FormalParameterList)? PONTOV id2=IDENTIFIER;
procedure_identification:
	'procedure' procedure_identifier;
FormalParameterList:
    PARENTESQ FormalParameterSection+=FormalParameterSection (PONTOV FormalParameterSection+=FormalParameterSection)* PARENTDIR;
FormalParameterSection:
    valueParameterSection=ValueParameterSection |
    variableParamenterSection=VariableParamenterSection |
    procedureHeading=procedure_heading |
    functionHeading=function_heading;
ValueParameterSection:
    identifierList=identifier_list DOISPONTOS parameterType=ParameterType;
VariableParamenterSection:
    'var' identifierList=identifier_list DOISPONTOS parameterType=ParameterType;
ParameterType:
    id=IDENTIFIER |
    conformantArraySchema=ConformantArraySchema;
ConformantArraySchema:
    PackedConformantArraySchema |
    UnpackedConformantArraySchema ;
PackedConformantArraySchema:
    'packed array' COLCHETEESQ boundSpecification=BoundSpecification COLCHETEDIR 'of' id=IDENTIFIER;
UnpackedConformantArraySchema:
    'array' COLCHETEESQ boundSpecification+=BoundSpecification (PONTOV boundSpecification+=BoundSpecification)* 
    COLCHETEDIR 'of' (id=IDENTIFIER | conformantArraySchema=ConformantArraySchema);
BoundSpecification:
    id1=IDENTIFIER PONTOPONTO id2=IDENTIFIER DOISPONTOS id3=IDENTIFIER;

//STATEMENTS
StatementSequence:
    statement+=Statement (PONTOV statement+=Statement)*;
Statement:
	(label DOISPONTOS )? statement=(SimpleStatement | StructuredStatement);
SimpleStatement:
	(AssignmentStatement | ProcedureStatement | GotoStatement);
AssignmentStatement:
    (variable='variable' | identifier=IDENTIFIER) ATRIBUICAO expression=Expression;
ProcedureStatement:
    name=IDENTIFIER actualParameterList=('ActualParameterList')?;
GotoStatement:
    'goto' label;
StructuredStatement:
    CompoundStatement |
    RepetitiveStatement |
    ConditionalStatement | 
    WithStatement;
CompoundStatement:
    'begin' statementSequence=StatementSequence 'end';
RepetitiveStatement:
    Whilestatement |
    RepeatStatement |
    ForStatement    ;
Whilestatement:
    'while' expression=Expression 'do' statement=Statement;
RepeatStatement:
    'repeat' statementSequence=StatementSequence 'until' expression=Expression    ;
ForStatement:
	'for' name=IDENTIFIER ATRIBUICAO expression1=Expression ('to' | 'downto' ) expression2=Expression 'do' statement=Statement;
ConditionalStatement:
    ifStatement=IfStatement | caseStatement=CaseStatement;
IfStatement:
    'if' expression=Expression 'then' ifStatement=Statement (=>'else' elseStatement=Statement)?;
CaseStatement:
    'case' expression=Expression 'of' caseLimb+=CaseLimb (PONTOV caseLimb+=CaseLimb)* (PONTOV)? 'end';
CaseLimb:
    caseLabelList=case_label_list DOISPONTOS statement=Statement;
case_label_list:
    constant+=constant (VIRGULA constant+=constant)*;
WithStatement: 
    'with' variable+=Variable (VIRGULA variable+=Variable)* 'do' statement=Statement;

//EXPRESSIONS
Expression:
    simpleExpression+=SimpleExpression (relational_operator+=RELATIONALOPERATOR simpleExpression+=SimpleExpression)?;
SimpleExpression:
    ('+' | '-')? term+=Term (ADDITIONOPERATOR term+=Term )*
;
Term:
    factor+=Factor (MULTIPLICATIONOPERATOR factor+=Factor)*;
Factor:
	(=>functionDesignator=FunctionDesignator)
    variable=Variable | number=number | string=STRING1 | set=Set | nil='nil' | id=IDENTIFIER | 
    PARENTESQ expression=Expression PARENTDIR | 'not' factor=Factor ;
Variable:
    name=IDENTIFIER variable1=(Variable1)?;
Variable1:
    (COLCHETEESQ expressionList=ExpressionList COLCHETEDIR) variable1=Variable1 |
    (PONTO name=IDENTIFIER) variable1=Variable1 |
    CHAPEU variable1=Variable1;
Set:
    COLCHETEESQ elementList=ElementList COLCHETEDIR;
ElementList:
	{ElementList}
    (expression+=Expression (VIRGULA expression+=Expression)* )?;
FunctionDesignator:
    name=IDENTIFIER 'actualParameterList'?;
entire_variable:
	variable_identifier | field_identifier; 

//TYPES
type:
    simpleType=simple_type |
    structuredType=structured_type |
    pointerType=pointer_type |
    name=IDENTIFIER;
simple_type:
	=>(primitiveType=('boolean'|'char'|'integer'|'real'))
    subrangeType=subrange_type | enumeratedType=enumerated_type;
enumerated_type:
    PARENTESQ identifierList=identifier_list PARENTDIR;
subrange_type:
    constant=constant PONTOPONTO constant2=constant;
structured_type:
    ('packed')? unpackedStructuredType=unpacked_structured_type;
unpacked_structured_type:
    arrayType=array_type |
    recordType=record_type |
    setType=set_type |
    fileType=file_type;
array_type:
    'array' COLCHETEESQ simpleType+=simple_type (VIRGULA simpleType+=simple_type)* COLCHETEDIR 'of' type=type;
record_type:
	'record' fieldlist=field_list 'end';
set_type:
	'set' 'of' type=type;
file_type:
	'file' 'of' type=type;
pointer_type:
	CHAPEU name=IDENTIFIER;
	
//RECORD FIELDS
field_list:
	{field_list}
    ( (fixedPart=fixed_part (PONTOV variantPart=variant_part)? | variantPart=variant_part ) (PONTOV)? )? ;
fixed_part:
    recordSection+=record_section (PONTOV recordSection+=record_section)*;
record_section:
    identifierList=identifier_list DOISPONTOS type=type;
variant_part:
    'case' tagfield=tag_field id=IDENTIFIER 'of' variant+=variant (PONTOV variant+=variant)*;
tag_field:
	{tag_field}
    (id=IDENTIFIER DOISPONTOS)?;
variant:
    caseLabelList=case_label_list DOISPONTOS PARENTESQ fieldList=field_list PARENTDIR;

//VARIABLE AND IDENTIFIER CATEGORIES
field_identifier:
	IDENTIFIER;
constant_identifier:
	IDENTIFIER;
variable_identifier:
	IDENTIFIER;
type_identifier:
	IDENTIFIER;
procedure_identifier:
	IDENTIFIER;
function_identifier:
	IDENTIFIER;
bound_identifier:
	IDENTIFIER;

//LOW LEVEL DEFINITIONS
ExpressionList:
    expression+=Expression (VIRGULA expression+=Expression)*;
identifier_list:
    ids+=IDENTIFIER (VIRGULA ids+=IDENTIFIER)*;
number:
    integer=INTEGER_NUMBER |
    real=REAL_NUMBER;
label:
    int=INTEGER_NUMBER;
scale_factor:
	("E" | "e")digit_sequence;
terminal UNSIGNED_DIGIT_SEQUENCE:
	('0'..'9') ('0'..'9')*;
digit_sequence:
	(sign)? UNSIGNED_DIGIT_SEQUENCE;
sign:
	'+' | '-';
constant:
    ('+' | '-')? (name=IDENTIFIER | number=number) | string=STRING1;    
terminal RELATIONALOPERATOR:
    IGUAL | DIFERENTE | MENOR | MENORIGUAL | MAIOR | MAIORIGUAL | 'in'
;

terminal ADDITIONOPERATOR:
    '+' | '-' | 'or';
terminal MULTIPLICATIONOPERATOR:
    MULTIP | DIVISAO | 'div' | 'mod' | 'and';
terminal INTEGER_NUMBER:
    ('+' | '-')? DIGIT+;
terminal REAL_NUMBER:
    ('+' | '-')? DIGIT+ ((PONTO DIGIT* (EXPOENTE ('+' | '-')? DIGIT+)?) |(EXPOENTE ('+' | '-')? DIGIT+) );
terminal STRING1:
    ASPASSIMPLES STRINGCHARACTER (STRINGCHARACTER)* ASPASSIMPLES;
terminal STRINGCHARACTER:
"''" | (LETTER | DIGIT);

//TERMINAIS
terminal fragment DIFERENTE : "<>";
terminal fragment MENOR : "<";
terminal fragment MENORIGUAL : "<=";
terminal fragment MAIOR : ">";
terminal fragment MAIORIGUAL : ">=";

terminal fragment MULTIP : "*";
terminal fragment DIVISAO : "/";
terminal PONTOV : ";";
terminal VIRGULA : ",";
terminal PONTO : ".";
terminal DOISPONTOS : ":";
terminal ATRIBUICAO : ":=";
terminal PARENTESQ : "(";
terminal PARENTDIR : ")";
terminal COLCHETEESQ : "[";
terminal COLCHETEDIR : "]";
terminal PONTOPONTO : "..";
terminal CHAPEU : "^";
terminal fragment ASPASSIMPLES : "'";
terminal fragment IGUAL : "==";
terminal IG: "=";                                   //OBS
terminal fragment LETTER : ('a'..'z' |  'A'..'Z');
terminal fragment DIGIT : ('0'..'9');
terminal fragment EXPOENTE: 'E' | 'e';

terminal IDENTIFIER:
    (('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|'_'|('0'..'9'))*;

terminal WS: 
    (' '|'\t'|'\r'|'\n')+
;