grammar org.xtext.example.mydsl.Pascal with org.eclipse.xtext.common.Terminals

generate pascal "http://www.xtext.org/example/mydsl/Pascal"

Model:
	programs+=program*;

//PROGRAMS AND BLOCKS
program:
	program_heading block PONTO;
program_heading:
	'program' IDENTIFIER (PARENTESQ  identifier_list PARENTDIR)? PONTOV ;
block:
	declarationPart=DeclarationPart statementPart=StatementPart;
DeclarationPart:
	(label_declaration_part)? (constant_definition_part)? (type_definition_part)? (variable_declaration_part)? procedure_and_function_declaration_part;
label_declaration_part:
	'label' label (VIRGULA label)* PONTOV;
constant_definition_part:
	'const' constant_definition PONTOV (constant_definition PONTOV)*;
constant_definition:
	IDENTIFIER IG constant;
type_definition_part:
	'type' type_definition PONTOV (type_definition PONTOV)*; 
type_definition:
	IDENTIFIER IG type;
variable_declaration_part:
	'var' variable_declaration PONTOV (variable_declaration PONTOV)*;
variable_declaration:
	identifier_list DOISPONTOS type; 
procedure_and_function_declaration_part:
	{procedure_and_function_declaration_part}
    ( (procedureDeclaration+=ProcedureDeclaration | functionDeclaration+=FunctionDeclaration) PONTOV )*;
ProcedureDeclaration:
    'procedure' IDENTIFIER (FormalParameterList)? PONTOV block;
FunctionDeclaration:
    'function' IDENTIFIER (FormalParameterList)? DOISPONTOS type PONTOV block ;
StatementPart:
	'begin' StatementSequence 'end'; 

//PROCEDURE AND FUNCTION DEFINITIONS
procedure_heading:
	'procedure' IDENTIFIER ('formal_parameter_list')?;
function_heading:
    'function' id1=IDENTIFIER FormalParameterList=(FormalParameterList)? PONTOV id2=IDENTIFIER;
procedure_identification:
	'procedure' procedure_identifier;
FormalParameterList:
    PARENTESQ FormalParameterSection+=FormalParameterSection (PONTOV FormalParameterSection+=FormalParameterSection)* PARENTDIR;
FormalParameterSection:
    valueParameterSection=ValueParameterSection |
    variableParamenterSection=VariableParamenterSection |
    procedureHeading=procedure_heading |
    functionHeading=function_heading;
ValueParameterSection:
    identifierList=identifier_list DOISPONTOS parameterType=ParameterType;
VariableParamenterSection:
    'var' identifierList=identifier_list DOISPONTOS parameterType=ParameterType;
ParameterType:
    id=IDENTIFIER |
    conformantArraySchema=ConformantArraySchema;
ConformantArraySchema:
    PackedConformantArraySchema |
    UnpackedConformantArraySchema ;
PackedConformantArraySchema:
    'packed array' COLCHETEESQ boundSpecification=BoundSpecification COLCHETEDIR 'of' id=IDENTIFIER;
UnpackedConformantArraySchema:
    'array' COLCHETEESQ boundSpecification+=BoundSpecification (PONTOV boundSpecification+=BoundSpecification)* 
    COLCHETEDIR 'of' (id=IDENTIFIER | conformantArraySchema=ConformantArraySchema);
BoundSpecification:
    id1=IDENTIFIER PONTOPONTO id2=IDENTIFIER DOISPONTOS id3=IDENTIFIER;

//STATEMENTS
StatementSequence:
    statement+=Statement (PONTOV statement+=Statement)*;
Statement:
	(label DOISPONTOS )? statement=(SimpleStatement | StructuredStatement);
SimpleStatement:
	(AssignmentStatement | ProcedureStatement | GotoStatement);
AssignmentStatement:
    (variable='variable' | identifier=IDENTIFIER) ATRIBUICAO expression=Expression;
ProcedureStatement:
    name=IDENTIFIER actualParameterList=('ActualParameterList')?;
GotoStatement:
    'goto' label;
StructuredStatement:
    CompoundStatement |
    RepetitiveStatement |
    ConditionalStatement | 
    WithStatement;
CompoundStatement:
    'begin' statementSequence=StatementSequence 'end';
RepetitiveStatement:
    Whilestatement |
    RepeatStatement |
    ForStatement    ;
Whilestatement:
    'while' expression=Expression 'do' statement=Statement;

RepeatStatement:
    'repeat' statementSequence=StatementSequence 'until' expression=Expression    ;
ForStatement:
    'for';
ConditionalStatement:
    'if';
WithStatement: 
    'with';
case_label_list:
	constant (VIRGULA constant)*;

//EXPRESSIONS
Expression:
    simpleExpression+=SimpleExpression (relational_operator+=RELATIONALOPERATOR simpleExpression+=SimpleExpression)?;
SimpleExpression:
    ('+' | '-')? term+=Term (ADDITIONOPERATOR term+=Term )*
;
Term:
    factor+=Factor (MULTIPLICATIONOPERATOR factor+=Factor)*;
Factor:
	(=>functionDesignator=FunctionDesignator)
    variable=Variable | number=number | string=STRING1 | set=Set | nil='nil' | id=IDENTIFIER | 
    PARENTESQ expression=Expression PARENTDIR | 'not' factor=Factor ;
Variable:
    name=IDENTIFIER variable1=(Variable1)?
;
Variable1:
    (COLCHETEESQ expressionList=ExpressionList COLCHETEDIR) variable1=Variable1 |
    (PONTO name=IDENTIFIER) variable1=Variable1 |
    CHAPEU variable1=Variable1;
Set:
    COLCHETEESQ elementList=ElementList COLCHETEDIR;
ElementList:
	{ElementList}
    (expression+=Expression (VIRGULA expression+=Expression)* )?;
FunctionDesignator:
    name=IDENTIFIER 'actualParameterList'?;
entire_variable:
	variable_identifier | field_identifier; 

//TYPES
type:
	simple_type | structured_type | pointer_type | type_identifier | 'TESTE';
simple_type:
	subrange_type | enumerated_type;
enumerated_type:
	PARENTESQ identifier_list PARENTDIR; 
subrange_type:
	lower_bound PONTOPONTO upper_bound;
lower_bound:
	constant;
upper_bound:
	constant;
structured_type:
	('packed')? unpacked_structured_type;
unpacked_structured_type:
	array_type | record_type | set_type | file_type;
array_type:
	'array';
index_type:
	simple_type;
element_type:
	type;  
record_type:
	'record' field_list 'end';
set_type:
	'set' 'of' base_type;
base_type:
	type;
file_type:
	'file' 'of' file_component_type;
file_component_type:
	type;
pointer_type:
CHAPEU type_identifier;
	
//RECORD FIELDS
field_list:
	((fixed_part (PONTOV variant_part)? | variant_part) (PONTOV)?)?;
fixed_part:
	record_section (PONTOV record_section)*;
record_section:
	identifier_list DOISPONTOS type;
variant_part:
	'case' tag_field type_identifier 'of' variant (PONTOV variant)*;
tag_field:
	(IDENTIFIER DOISPONTOS)?;
variant:
	case_label_list DOISPONTOS PARENTESQ field_list PARENTDIR;  

//VARIABLE AND IDENTIFIER CATEGORIES
field_identifier:
	IDENTIFIER;
constant_identifier:
	IDENTIFIER;
variable_identifier:
	IDENTIFIER;
type_identifier:
	IDENTIFIER;
procedure_identifier:
	IDENTIFIER;
function_identifier:
	IDENTIFIER;
bound_identifier:
	IDENTIFIER;

//LOW LEVEL DEFINITIONS
ExpressionList:
    expression+=Expression (VIRGULA expression+=Expression)*;
identifier_list:
	IDENTIFIER (VIRGULA IDENTIFIER)*;
number:
	integer_number | real_number;
integer_number:
	digit_sequence;
real_number:
	digit_sequence PONTO (UNSIGNED_DIGIT_SEQUENCE)? (scale_factor) | digit_sequence scale_factor;
scale_factor:
	("E" | "e")digit_sequence;
terminal UNSIGNED_DIGIT_SEQUENCE:
	('0'..'9') ('0'..'9')*;
digit_sequence:
	(sign)? UNSIGNED_DIGIT_SEQUENCE;
sign:
	'+' | '-';
label:
	integer_number;
constant:
	(sign)? (constant_identifier | number) | STRING;
terminal RELATIONALOPERATOR:
    IGUAL | DIFERENTE | MENOR | MENORIGUAL | MAIOR | MAIORIGUAL | 'in'
;

terminal ADDITIONOPERATOR:
    '+' | '-' | 'or';
terminal MULTIPLICATIONOPERATOR:
    MULTIP | DIVISAO | 'div' | 'mod' | 'and';
terminal STRING1:
    ASPASSIMPLES STRINGCHARACTER (STRINGCHARACTER)* ASPASSIMPLES;
terminal STRINGCHARACTER:
"''" | (LETTER | DIGIT);

//TERMINAIS
terminal fragment DIFERENTE : "<>";
terminal fragment MENOR : "<";
terminal fragment MENORIGUAL : "<=";
terminal fragment MAIOR : ">";
terminal fragment MAIORIGUAL : ">=";

terminal fragment MULTIP : "*";
terminal fragment DIVISAO : "/";
terminal PONTOV : ";";
terminal VIRGULA : ",";
terminal PONTO : ".";
terminal DOISPONTOS : ":";
terminal ATRIBUICAO : ":=";
terminal PARENTESQ : "(";
terminal PARENTDIR : ")";
terminal COLCHETEESQ : "[";
terminal COLCHETEDIR : "]";
terminal PONTOPONTO : "..";
terminal CHAPEU : "^";
terminal fragment ASPASSIMPLES : "'";
terminal fragment IGUAL : "==";
terminal IG: "=";                                   //OBS
terminal fragment LETTER : ('a'..'z' |  'A'..'Z');
terminal fragment DIGIT : ('0'..'9');
terminal fragment EXPOENTE: 'E' | 'e';

terminal IDENTIFIER:
    (('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|'_'|('0'..'9'))*;

terminal WS: 
    (' '|'\t'|'\r'|'\n')+
;